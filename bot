tôihttps://nodejs.org/fr

npx create-react-app chatbot_frontend


cd chatbot_frontend
npm install axios

import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import './App.css';

function App() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const messageContainerRef = useRef(null);

  // Lấy lịch sử trò chuyện khi tải trang
  useEffect(() => {
    const fetchMessages = async () => {
      try {
        const response = await axios.get('http://localhost:8000/api/messages/');
        setMessages(response.data);
      } catch (error) {
        console.error('Lỗi khi lấy tin nhắn:', error);
      }
    };
    fetchMessages();
  }, []);

  // Gửi tin nhắn
  const sendMessage = async () => {
    if (input.trim() === '') return;

    const userMessage = { sender: 'user', text: input };
    setMessages(prevMessages => [...prevMessages, userMessage]);

    try {
      const response = await axios.post('http://localhost:8000/api/chat/', { message: input });
      const botMessage = { sender: 'bot', text: response.data.response };
      setMessages(prevMessages => [...prevMessages, botMessage]);
    } catch (error) {
      console.error('Lỗi khi gửi tin nhắn:', error);
    }
    setInput('');
  };

  // Cuộn xuống dưới cùng của danh sách tin nhắn
  useEffect(() => {
    if (messageContainerRef.current) {
      messageContainerRef.current.scrollTop = messageContainerRef.current.scrollHeight;
    }
  }, [messages]);

  return (
    <div className="chat-container">
      <div className="input-container">
        <input
          type="text"
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyPress={e => e.key === 'Enter' && sendMessage()}
          placeholder="Hỏi bất kỳ điều gì..."
        />
        <button onClick={sendMessage}>Gửi</button>
      </div>
      <div className="message-container" ref={messageContainerRef}>
        {messages.map((message, index) => (
          <div key={index} className={`message ${message.sender}`}>
            {message.text}
          </div>
        ))}
      </div>
    </div>
  );
}

export default App;



.chat-container {
  position: relative;
  width: 100vw;
  height: 100vh;
}

.input-container {
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  width: 80%;
  max-width: 600px;
}

.input-container input {
  flex: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px 0 0 5px;
}

.input-container button {
  padding: 10px;
  border: none;
  background-color: #007BFF;
  color: white;
  border-radius: 0 5px 5px 0;
}

.message-container {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 400px; /* Có thể điều chỉnh */
  overflow-y: auto;
  padding: 10px;
  background-color: #f9f9f9;
  border-top: 1px solid #ddd;
}

.message {
  margin: 5px 0;
  padding: 10px;
  border-radius: 10px;
  max-width: 80%;
}

.message.user {
  background-color: #DCF8C6; /* Màu xanh nhạt cho người dùng */
  margin-left: auto;
}

.message.bot {
  background-color: #F0F0F0; /* Màu xám nhạt cho bot */
  margin-right: auto;
}



python -m venv myenv

pip install django djangorestframework django-cors-headers
django-admin startproject chatbot_backend
cd chatbot_backend

pip install Django
python manage.py startapp chat


Trong file chatbot_backend/settings.py, thêm các ứng dụng vào INSTALLED_APPS:


INSTALLED_APPS = [
    ...
    'rest_framework',
    'corsheaders',
    'chat',
]


Thêm middleware và cấu hình CORS:


MIDDLEWARE = [
    ...
    'corsheaders.middleware.CorsMiddleware',
    ...
]

CORS_ALLOW_ALL_ORIGINS = True



chat/models.py

from django.db import models

class Message(models.Model):
    SENDER_CHOICES = [
        ('user', 'User'),
        ('bot', 'Bot'),
    ]
    sender = models.CharField(max_length=4, choices=SENDER_CHOICES)
    text = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.sender}: {self.text[:20]}"




pip install djangorestframework
pip install django-cors-headers


python manage.py makemigrations
python manage.py migrate




Trong chat/serializers.py:


from rest_framework import serializers
from .models import Message

class MessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message
        fields = ['id', 'sender', 'text', 'timestamp']



Trong chat/views.py


from rest_framework import generics
from rest_framework.views import APIView
from rest_framework.response import Response
from .models import Message
from .serializers import MessageSerializer

class MessageList(generics.ListAPIView):
    queryset = Message.objects.all().order_by('timestamp')
    serializer_class = MessageSerializer

class ChatView(APIView):
    def post(self, request):
        user_message_text = request.data.get('message')
        if not user_message_text:
            return Response({'error': 'Tin nhắn không được để trống'}, status=400)

        # Lưu tin nhắn của người dùng
        user_message = Message.objects.create(sender='user', text=user_message_text)

        # Tạo phản hồi từ bot
        bot_response_text = self.get_bot_response(user_message_text)
        Message.objects.create(sender='bot', text=bot_response_text)

        return Response({'response': bot_response_text})

    def get_bot_response(self, user_message):
        # Logic phản hồi đơn giản dựa trên từ khóa
        keywords = {
            'hello': 'Xin chào bạn!',
            'how are you': 'Mình khỏe, cảm ơn bạn!',
            'bye': 'Tạm biệt!',
        }
        for key in keywords:
            if key in user_message.lower():
                return keywords[key]
        return 'Mình không biết trả lời thế nào.'




chat/urls.py:


from django.urls import path
from .views import MessageList, ChatView

urlpatterns = [
    path('messages/', MessageList.as_view(), name='message-list'),
    path('chat/', ChatView.as_view(), name='chat'),
]



Trong chatbot_backend/urls.py:


from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('chat.urls')),
]

python manage.py runserver
Backend sẽ chạy tại http://localhost:8000



import torch
import torch.nn as nn
from transformers import AutoModel, AutoTokenizer
from torch.utils.data import DataLoader, Dataset
import torch.nn.functional as F

# Hàm mất mát InfoNCE
class InfoNCELoss(nn.Module):
    def __init__(self, temperature=0.07):
        super(InfoNCELoss, self).__init__()
        self.temperature = temperature

    def forward(self, features_1, features_2, labels):
        # Chuẩn hóa đặc trưng
        features_1 = F.normalize(features_1, p=2, dim=1)
        features_2 = F.normalize(features_2, p=2, dim=1)
        # Tính độ tương đồng
        similarity_matrix = torch.matmul(features_1, features_2.T) / self.temperature
        # Tạo nhãn cho cặp positive (cùng chỉ số)
        batch_size = features_1.shape[0]
        labels = torch.arange(batch_size, device=features_1.device)
        # Tính loss
        loss = F.cross_entropy(similarity_matrix, labels)
        return loss

# Dataset tùy chỉnh
class TextPairDataset(Dataset):
    def __init__(self, texts_1, texts_2, labels):
        self.texts_1 = texts_1  # Danh sách văn bản 1
        self.texts_2 = texts_2  # Danh sách văn bản 2 (positive/negative pairs)
        self.labels = labels    # Nhãn: 1 cho positive, 0 cho negative
        self.tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")

    def __len__(self):
        return len(self.texts_1)

    def __getitem__(self, idx):
        text_1 = self.texts_1[idx]
        text_2 = self.texts_2[idx]
        label = self.labels[idx]
        encoding_1 = self.tokenizer(text_1, return_tensors="pt", padding="max_length", truncation=True, max_length=128)
        encoding_2 = self.tokenizer(text_2, return_tensors="pt", padding="max_length", truncation=True, max_length=128)
        return {
            "input_ids_1": encoding_1["input_ids"].squeeze(),
            "attention_mask_1": encoding_1["attention_mask"].squeeze(),
            "input_ids_2": encoding_2["input_ids"].squeeze(),
            "attention_mask_2": encoding_2["attention_mask"].squeeze(),
            "label": label
        }

# Mô hình
class TextContrastiveModel(nn.Module):
    def __init__(self, model_name="bert-base-uncased"):
        super(TextContrastiveModel, self).__init__()
        self.bert = AutoModel.from_pretrained(model_name)
        self.pooling = nn.AdaptiveAvgPool1d(1)  # Mean pooling

    def forward(self, input_ids, attention_mask):
        outputs = self.bert(input_ids, attention_mask=attention_mask)
        # Lấy hidden states của token [CLS] hoặc mean pooling
        embeddings = outputs.last_hidden_state.mean(dim=1)  # Mean pooling
        return embeddings

# Dữ liệu mẫu
texts_1 = ["I love this movie!", "This film is great!", "I hate this movie."]
texts_2 = ["This movie is amazing!", "I enjoyed the film.", "This film is terrible."]
labels = [1, 1, 0]  # 1: positive pair, 0: negative pair

# Tạo dataset và dataloader
dataset = TextPairDataset(texts_1, texts_2, labels)
dataloader = DataLoader(dataset, batch_size=2, shuffle=True)

# Khởi tạo mô hình và hàm mất mát
model = TextContrastiveModel()
criterion = InfoNCELoss(temperature=0.07)
optimizer = torch.optim.Adam(model.parameters(), lr=2e-5)

# Huấn luyện
model.train()
for epoch in range(3):
    for batch in dataloader:
        optimizer.zero_grad()
        input_ids_1 = batch["input_ids_1"]
        attention_mask_1 = batch["attention_mask_1"]
        input_ids_2 = batch["input_ids_2"]
        attention_mask_2 = batch["attention_mask_2"]
        labels = batch["label"].float()

        # Trích xuất đặc trưng
        features_1 = model(input_ids_1, attention_mask_1)
        features_2 = model(input_ids_2, attention_mask_2)

        # Tính loss
        loss = criterion(features_1, features_2, labels)
        loss.backward()
        optimizer.step()
        print(f"Epoch {epoch+1}, Loss: {loss.item()}")

# Phân loại (tinh chỉnh)
class TextClassifier(nn.Module):
    def __init__(self, pretrained_model):
        super(TextClassifier, self).__init__()
        self.bert = pretrained_model
        self.fc = nn.Linear(768, 2)  # Giả sử phân loại nhị phân (positive/negative)

    def forward(self, input_ids, attention_mask):
        embeddings = self.bert(input_ids, attention_mask)
        logits = self.fc(embeddings)
        return logits

# Tinh chỉnh cho phân loại
classifier = TextClassifier(model)
# Tiếp tục huấn luyện với cross-entropy loss cho bài toán phân loại
